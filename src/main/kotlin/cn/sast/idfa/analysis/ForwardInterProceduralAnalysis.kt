package cn.sast.idfa.analysis

import cn.sast.api.config.ExtSettings
import cn.sast.api.config.StaticFieldTrackingMode
import cn.sast.common.OS
import cn.sast.coroutines.caffine.impl.FastCacheImpl
import cn.sast.graph.HashMutableDirectedGraph
import cn.sast.idfa.progressbar.ProgressBarExt
import cn.sast.idfa.progressbar.ProgressBarExt.DefaultProcessInfoRenderer
import com.google.common.base.Stopwatch
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Job
import kotlinx.coroutines.sync.Semaphore
import me.tongfei.progressbar.ProgressBar
import mu.KLogger
import org.utbot.common.LoggingKt
import org.utbot.common.Maybe
import soot.SootMethod
import soot.jimple.infoflow.collect.ConcurrentHashSet
import soot.jimple.infoflow.solver.executors.InterruptableExecutor
import soot.toolkits.graph.DirectedGraph
import java.time.LocalDateTime
import java.util.ArrayList
import java.util.Collections
import java.util.concurrent.LinkedBlockingQueue
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicInteger
import java.util.concurrent.atomic.AtomicLong
import kotlin.coroutines.CoroutineContext

/**
 * A cleaned‑up skeleton of the original class generated by Vineflower.
 * Many implementations are left as TODOs – fill them according to your logic.
 * The goal is: **this file compiles** so you can iteratively refine behaviour.
 */
@Suppress("UNUSED_PARAMETER", "UNCHECKED_CAST")
abstract class ForwardInterProceduralAnalysis<
        M, N, A, R, CTX : Context<M, N, A>
        >(
   /** Human‑readable identifier shown in logs & UI. */
   val analysisName: String
) : InterProceduralAnalysis<M, N, A>(/*buildFixpoint =*/ false), Comparable<ForwardInterProceduralAnalysis<M, N, A, R, CTX>> {

   /* ----------------------------------------------------
    *  Runtime metrics / switches
    * ---------------------------------------------------- */
   private val stopWatch: Stopwatch = Stopwatch.createUnstarted()
   var timeOutDuration: Long = -1L
   var timeOutOn: Boolean = false
   var usedTimeSec: Double = .0
      private set
   var isTimeout: Boolean = false
      private set
   var limitedAnalytics: Boolean = false

   /* ----------------------------------------------------
    *  Configuration knobs
    * ---------------------------------------------------- */
   var numberThreads: Int = OS.maxThreadNum
   var staticFieldTrackingMode: StaticFieldTrackingMode = StaticFieldTrackingMode.ContextFlowSensitive
   open val progressBarVolume: Int = 100

   /* ----------------------------------------------------
    *  Shared state across whole analysis session
    * ---------------------------------------------------- */
   val progressBarExt = ProgressBarExt(0, 0, 3, null)
   val reachableMethods = ConcurrentHashSet<M>()
   var directedGraph: HashMutableDirectedGraph<N>? = null
   val contextStateId = AtomicLong(0)
   lateinit var cache: RecCoroutineLoadingCache<FactKey<M, N, A>, CTX>
   var dataFlowInterProceduralCalleeTimeOut: Int = -1
   var dataFlowInterProceduralCalleeDepChainMaxNum: Long = -1
   private val transformStmtTotalCount = AtomicInteger()
   private val curAnalysingMethods = Sets.newConcurrentHashSet<M>()

   /** Convenience getter for the ⊥ value provided by the lattice implementation. */
   protected val bottom: A get() = bottomValue()

   /* ====================================================
    *  Constructors & utility overrides
    * ==================================================== */

   override fun compareTo(other: ForwardInterProceduralAnalysis<M, N, A, R, CTX>): Int =
      analysisName.compareTo(other.analysisName)

   override fun toString(): String = "ForwardInterProceduralAnalysis(name=$analysisName)"

   /* ====================================================
    *  Abstract factory hooks – must be implemented by subclasses
    * ==================================================== */

   /** Provide a freshly‑initialised [Context] for `method` */
   abstract fun makeContext(
      method: M,
      cfg: DirectedGraph<N>,
      entryValue: A,
      reverse: Boolean,
      isAnalyzable: Boolean
   ): CTX

   /** Build or fetch a CFG for [method]. */
   abstract fun getCfg(method: M, isAnalyzable: Boolean): DirectedGraph<N>

   /** Map a normal intra‑procedural edge. */
   abstract suspend fun normalFlowFunction(
      context: CTX,
      node: N,
      succ: N,
      inValue: A,
      isNegativeBranch: AtomicBoolean
   ): A

   /** Whether we are willing to analyse [callee] given incoming fact [inValue]. */
   abstract fun isAnalyzable(callee: M, inValue: A): Boolean

   /* ====================================================
    *  Helpers – most are re‑implemented from the original decompilation
    * ==================================================== */

   open fun ProgressBar.wrapperCustom(): DefaultProcessInfoRenderer =
      progressBarExt.wrapper(this) {
         DefaultProcessInfoRenderer(it.first, it.second, this@ForwardInterProceduralAnalysis).apply {
            if (limitedAnalytics) extraMessage = " !" else extraMessage = ""
         }
      }

   /** Placeholder – supply cache config here. */
   open fun cacheConfig() {}

   /** Create, seed and return a brand‑new [Context] for [method]. */
   @Suppress("NAME_SHADOWING")
   open fun newContext(
      cfg: DirectedGraph<N>,
      method: M,
      entryValue: A,
      isAnalyzable: Boolean
   ): CTX {
      programRepresentation().setOwnerStatement(cfg as Iterable<N>, method)
      val ctx = makeContext(method, cfg, entryValue, reverse = false, isAnalyzable = isAnalyzable)
      ctx.bottomValue = bottom
      // initialise IN map
      cfg.iterator().forEachRemaining { n ->
         if (cfg.getHeads().contains(n)) ctx.setValueBefore(n, entryValue) else ctx.setValueBefore(n, bottom)
      }
      ctx.initWorklist()
      ctx.setExitValue(bottom)
      return ctx
   }

   /* ====================================================
    *  Stub implementations replaced for now with TODOs
    * ==================================================== */

   open suspend fun computeInValue(context: CTX, node: N): A = TODO()
   open suspend fun computeEntryValue(context: CTX): A = TODO()
   open fun computeExitValue(context: CTX): A = TODO()
   open fun initCallEdgeValue(
      currentContext: CTX,
      node: N,
      callee: M,
      callSiteValue: A,
      inValue: A
   ): A = inValue

   open suspend fun evalCall(
      context: CTX,
      callee: M,
      node: N,
      succ: N,
      inValue: A
   ): InvokeResult<M, A, R>? = TODO()

   abstract fun recursiveCallFlowFunction(
      context: CTX,
      callee: M,
      node: N,
      succ: N,
      inValue: A,
      siteValue: A,
      isAnalyzable: Boolean
   ): InvokeResult<M, A, R>

   abstract fun failedInvokeResult(
      context: CTX,
      callee: M,
      node: N,
      succ: N,
      inValue: A,
      siteValue: A,
      isAnalyzable: Boolean
   ): InvokeResult<M, A, R>

   /* ====================================================
    *  Public drive functions – fill as needed
    * ==================================================== */

   open fun init(scope: CoroutineScope) {
      // configure asynchronous cache, etc.
      cacheConfig()
      // Placeholder: build cache with FastCacheImpl & your logic
   }

   open fun doAnalyze(scope: CoroutineScope, entries: Collection<M>): Pair<Job, DefaultProcessInfoRenderer?> {
      // heavily simplified – plug your coroutine pipeline
      TODO("wire your coroutine analysis here")
   }

   /* ====================================================
    *  Utility data‑classes (were badly decompiled before)
    * ==================================================== */

   data class FactKey<M, N, A>(
      val `in`: A,
      val method: M,
      val isAnalyzable: Boolean,
      val accessTimes: AtomicInteger = AtomicInteger()
   )

   data class InvokeResult<M, A, R>(
      val callee: M,
      val callSiteOutAbstract: A,
      val resultValue: R?
   )

   /* ====================================================
    *  Logger & companion utilities
    * ==================================================== */

   companion object {
      val logger: KLogger = LoggingKt.getLogger("ForwardInterProceduralAnalysis")
   }
}
